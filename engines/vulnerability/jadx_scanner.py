"""
engines/vulnerability/jadx_scanner.py

JADX Java Source Vulnerability Scanner

Scans decompiled .java files under jadx/sources/ for OWASP M1–M10
vulnerability patterns using Java-native syntax.

Evidence from this scanner provides human-readable Java source context
instead of low-level Smali bytecode, used in the Vulnerability section
of reports (ARA evidence remains in Smali format).

Returns List[VulnerabilitySignal] with source="jadx".
"""

from __future__ import annotations

import logging
import os
import re
from concurrent.futures import ProcessPoolExecutor, as_completed
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Tuple

logger = logging.getLogger(__name__)


# ═══════════════════════════════════════════════════════════════════════════
# SKIP PREFIXES — framework / third-party packages (noise reduction)
# ═══════════════════════════════════════════════════════════════════════════

_SKIP_PACKAGES = (
    "androidx/", "android/support/", "android/",
    "kotlin/", "kotlinx/",
    "com/google/android/gms/", "com/google/firebase/",
    "com/google/android/play/",
    "com/google/gson/", "com/google/protobuf/",
    "okhttp3/", "okio/", "retrofit2/",
    "com/squareup/", "com/bumptech/",
    "io/reactivex/", "io/realm/",
    "io/flutter/", "io/netty/",
    "org/apache/", "org/json/",
    "com/facebook/", "com/crashlytics/",
    "com/adjust/sdk/", "com/appsflyer/",
    "com/airbnb/lottie/",
    "org/bouncycastle/", "org/conscrypt/",
    "bolts/",
)


# ═══════════════════════════════════════════════════════════════════════════
# JAVA VULNERABILITY PATTERN DEFINITIONS
# ═══════════════════════════════════════════════════════════════════════════
# (regex_pattern, owasp_id, category, subtype, confidence)

_JAVA_VULN_PATTERNS: List[Tuple[str, str, str, str, float]] = [
    # ── M10  Weak Cryptography ────────────────────────────────────────
    (r'MessageDigest\.getInstance\s*\(\s*"MD5"',
        "M10", "INSUFFICIENT_CRYPTOGRAPHY", "weak_hash_md5", 0.85),
    (r'MessageDigest\.getInstance\s*\(\s*"SHA-?1"',
        "M10", "INSUFFICIENT_CRYPTOGRAPHY", "weak_hash_sha1", 0.80),
    (r'Cipher\.getInstance\s*\(\s*"[^"]*?/ECB',
        "M10", "INSUFFICIENT_CRYPTOGRAPHY", "insecure_cipher_ecb", 0.85),
    (r'Cipher\.getInstance\s*\(\s*"DES',
        "M10", "INSUFFICIENT_CRYPTOGRAPHY", "deprecated_crypto", 0.85),
    (r'Cipher\.getInstance\s*\(\s*"RC4',
        "M10", "INSUFFICIENT_CRYPTOGRAPHY", "weak_symmetric_cipher", 0.80),
    (r'SecureRandom\b.*?\.setSeed\s*\(',
        "M10", "INSUFFICIENT_CRYPTOGRAPHY", "weak_random_seed", 0.75),
    (r'NoPadding',
        "M10", "INSUFFICIENT_CRYPTOGRAPHY", "no_padding", 0.70),

    # ── M9  Insecure Data Storage ─────────────────────────────────────
    (r'getSharedPreferences\s*\(',
        "M9", "INSECURE_DATA_STORAGE", "sharedprefs_plaintext", 0.65),
    (r'MODE_WORLD_READABLE|MODE_WORLD_WRITEABLE',
        "M9", "INSECURE_DATA_STORAGE", "world_readable_storage", 0.90),
    (r'getExternal(?:Storage|Files)Dir',
        "M9", "INSECURE_DATA_STORAGE", "external_storage_access", 0.70),
    (r'(?:openOrCreateDatabase|SQLiteDatabase\.\w+\s*\()',
        "M9", "INSECURE_DATA_STORAGE", "sqlite_plaintext", 0.65),

    # ── M5  Insecure Communication ────────────────────────────────────
    (r'(?:TrustAllCertificates|AllowAllHostnameVerifier)',
        "M5", "INSECURE_COMMUNICATION", "trust_all_certs", 0.92),
    (r'setHostnameVerifier\s*\(\s*(?:ALLOW_ALL|null)',
        "M5", "INSECURE_COMMUNICATION", "hostname_bypass", 0.90),
    (r'checkServerTrusted\s*\([^)]*\)\s*\{[\s\n]*\}',
        "M5", "INSECURE_COMMUNICATION", "empty_trust_manager", 0.88),
    (r'HttpURLConnection|"http://"',
        "M5", "INSECURE_COMMUNICATION", "cleartext_http", 0.55),

    # ── M4  Input Validation ──────────────────────────────────────────
    (r'\.get(?:String|Int|Parcelable)Extra\s*\(',
        "M4", "INSUFFICIENT_INPUT_VALIDATION", "intent_input_unvalidated", 0.55),
    (r'WebView.*?loadUrl\s*\(|\.loadData\s*\(',
        "M4", "INSUFFICIENT_INPUT_VALIDATION", "webview_input", 0.60),

    # ── M7  Binary / WebView ──────────────────────────────────────────
    (r'addJavascriptInterface\s*\(',
        "M7", "INSUFFICIENT_BINARY_PROTECTIONS", "js_interface", 0.75),

    # ── M3  Authentication ────────────────────────────────────────────
    (r'(?:password|passwd|secret|api_?key)\s*=\s*"[^"]{4,}"',
        "M3", "INSECURE_AUTHENTICATION", "hardcoded_secret", 0.70),

    # ── M1  Credential / Exec ─────────────────────────────────────────
    (r'Runtime\.getRuntime\s*\(\s*\)\s*\.exec\s*\(',
        "M1", "IMPROPER_CREDENTIAL_USAGE", "runtime_exec", 0.80),

    # ── M8  Misconfiguration ─────────────────────────────────────────
    (r'Log\.\w+\s*\(\s*"[^"]*(?:password|token|secret|key)',
        "M8", "SECURITY_MISCONFIGURATION", "sensitive_logging", 0.72),

    # ── M6  Privacy ──────────────────────────────────────────────────
    (r'TelephonyManager\s*.*?get(?:DeviceId|Imei|Line1Number)\s*\(',
        "M6", "INADEQUATE_PRIVACY_CONTROLS", "device_id_access", 0.75),
    (r'getAdvertisingIdInfo|AdvertisingIdClient',
        "M6", "INADEQUATE_PRIVACY_CONTROLS", "advertising_id_access", 0.70),
    (r'(?:getLastKnownLocation|requestLocationUpdates)\s*\(',
        "M6", "INADEQUATE_PRIVACY_CONTROLS", "location_access", 0.65),
]

# Pre-compile all patterns
_COMPILED_PATTERNS = [
    (re.compile(p, re.IGNORECASE), oid, cat, sub, conf)
    for p, oid, cat, sub, conf in _JAVA_VULN_PATTERNS
]

# Quick file-level relevance filter — skip files with zero interesting keywords
_FILE_KEYWORDS = re.compile(
    r'(?:MessageDigest|Cipher|SecureRandom|SharedPreferences|'
    r'SQLiteDatabase|ExternalStorage|TrustManager|HostnameVerifier|'
    r'WebView|addJavascriptInterface|Runtime\.getRuntime|'
    r'password|secret|api_?key|TelephonyManager|AdvertisingId|'
    r'Log\.\w+|MODE_WORLD|HttpURLConnection|http://)',
    re.IGNORECASE,
)


# ═══════════════════════════════════════════════════════════════════════════
# FILE-LEVEL SCANNER (module-level — picklable for ProcessPool)
# ═══════════════════════════════════════════════════════════════════════════

def _scan_java_file(
    abs_path: str,
    sources_root: str,
) -> List[dict]:
    """Scan a single .java file for vulnerability patterns."""
    rel_path = os.path.relpath(abs_path, sources_root)

    # Skip framework/third-party packages
    rel_fwd = rel_path.replace("\\", "/")
    if any(rel_fwd.startswith(p) for p in _SKIP_PACKAGES):
        return []

    try:
        with open(abs_path, "r", encoding="utf-8", errors="replace") as fh:
            content = fh.read()
    except Exception:
        return []

    # Quick relevance filter
    if not _FILE_KEYWORDS.search(content):
        return []

    lines = content.split("\n")
    signals: List[dict] = []
    in_block_comment = False

    for i, line in enumerate(lines):
        stripped = line.strip()

        # Skip block comments
        if "/*" in stripped:
            in_block_comment = True
        if "*/" in stripped:
            in_block_comment = False
            continue
        if in_block_comment:
            continue

        # Skip empty, line comments
        if not stripped or stripped.startswith("//") or stripped.startswith("*"):
            continue

        # Skip import / package declarations
        if stripped.startswith("import ") or stripped.startswith("package "):
            continue

        for rx, owasp_id, category, subtype, confidence in _COMPILED_PATTERNS:
            if rx.search(stripped):
                line_no = i + 1
                signals.append({
                    "owasp_id":   owasp_id,
                    "category":   category,
                    "subtype":    subtype,
                    "source":     "jadx",
                    "file":       abs_path,
                    "line":       line_no,
                    "code":       stripped[:200],
                    "evidence":   [f"{abs_path}:{line_no} — {stripped[:120]}"],
                    "confidence": confidence,
                })
                break  # one match per line

    return signals


def _scan_java_batch(
    file_entries: List[Tuple[str, str]],
) -> Tuple[List[dict], int]:
    """Process-level worker: scan a batch of .java files."""
    all_signals: List[dict] = []
    for abs_path, sources_root in file_entries:
        all_signals.extend(_scan_java_file(abs_path, sources_root))
    return all_signals, len(file_entries)


# ═══════════════════════════════════════════════════════════════════════════
# PUBLIC CLASS
# ═══════════════════════════════════════════════════════════════════════════

class JadxVulnerabilityScanner:
    """
    Scans JADX-decompiled .java sources for OWASP M1–M10 vulnerability
    patterns using Java-native syntax.

    Produces VulnerabilitySignal objects with source='jadx' that carry
    human-readable Java code evidence.  Results are merged with smali
    scanner output; Java evidence is preferred for the vulnerability
    report while ARA evidence remains in Smali format.
    """

    def scan_all(
        self,
        jadx_dir: Path,
        progress_cb: Any = None,
    ) -> List:
        """
        Scan all .java files under jadx_dir/sources/.

        Parameters
        ----------
        jadx_dir : Path
            Root JADX output directory (contains sources/).
        progress_cb : callable, optional
            ``(pct: float, msg: str) -> None`` for progress updates (0–100).

        Returns
        -------
        List[VulnerabilitySignal]
        """
        from engines.vulnerability.models import VulnerabilitySignal

        sources_dir = jadx_dir / "sources"
        if not sources_dir.exists():
            logger.info("  [jadx-scan] no sources/ directory found")
            return []

        def _cb(pct: float, msg: str) -> None:
            if progress_cb:
                try:
                    progress_cb(pct, msg)
                except Exception:
                    pass

        # ── Collect all .java files ───────────────────────────────────
        file_entries: List[Tuple[str, str]] = []
        sources_str = str(sources_dir)
        for root, _, files in os.walk(sources_dir):
            for fname in files:
                if fname.endswith(".java"):
                    file_entries.append((os.path.join(root, fname), sources_str))

        total = len(file_entries)
        if not total:
            logger.info("  [jadx-scan] no .java files found")
            return []

        _cb(0, f"Scanning {total} Java source files")

        # ── Partition into chunks for parallel scanning ───────────────
        cpu = os.cpu_count() or 4
        num_workers = min(cpu, 8, max(1, total // 100))
        num_workers = max(1, num_workers)
        chunk_size = max(1, (total + num_workers - 1) // num_workers)
        chunks = [
            file_entries[i : i + chunk_size]
            for i in range(0, total, chunk_size)
        ]

        logger.info(
            f"  [jadx-scan] {total} files → {len(chunks)} chunk(s), "
            f"{num_workers} worker(s)"
        )

        # ── Launch ProcessPoolExecutor ────────────────────────────────
        all_dicts: List[dict] = []
        completed = 0

        with ProcessPoolExecutor(max_workers=num_workers) as pool:
            futures = {
                pool.submit(_scan_java_batch, chunk): idx
                for idx, chunk in enumerate(chunks)
            }
            for fut in as_completed(futures):
                try:
                    signals, count = fut.result()
                    all_dicts.extend(signals)
                    completed += count
                    _cb(
                        completed / total * 100,
                        f"Scanned {completed}/{total} Java files",
                    )
                except Exception as exc:
                    logger.warning(f"  [jadx-scan] worker error: {exc}")

        # ── Convert dicts → VulnerabilitySignal ───────────────────────
        result: List[VulnerabilitySignal] = [
            VulnerabilitySignal(**d) for d in all_dicts
        ]

        logger.info(
            f"  [jadx-scan] {len(result)} vulnerability signals "
            f"from {total} Java files"
        )
        return result

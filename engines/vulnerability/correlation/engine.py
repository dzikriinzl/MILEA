# engines/vulnerability/correlation/engine.py
from typing import List, Dict, Any
from .models import CorrelatedFinding
from .rules import CORRELATION_RULES


class CorrelationEngine:
    """
    STAGE 3: Correlation Engine
    Input:
      - List[VulnerabilityFinding]
      - UnifiedProtectionProfile (dict)
    Output: List[CorrelatedFinding OBJECTS]
    Responsibility:
      - Adjust severity based on protections
      - Determine mitigation_status
    Must NOT return dicts
    Must NOT calculate risk score
    """

    def __init__(self):
        self.rules = CORRELATION_RULES

    def correlate(
        self,
        vulnerabilities: List,
        protection_profile: Any
    ) -> List[CorrelatedFinding]:
        """
        Correlate vulnerabilities with protections
        Returns CorrelatedFinding objects (not dicts)
        """
        correlated = []

        # Convert protection profile to dict if needed
        if hasattr(protection_profile, 'as_dict'):
            profile_dict = protection_profile.as_dict()
        else:
            profile_dict = protection_profile if isinstance(protection_profile, dict) else {}

        for vuln in vulnerabilities:
            # Get correlation rule for this OWASP ID
            rule = self.rules.get(vuln.owasp_id, {})
            protection_deps = rule.get("depends_on", [])

            reasoning = []
            mitigated_count = 0

            # Check which protections are present
            for protection in protection_deps:
                posture = profile_dict.get(protection, {})

                if isinstance(posture, dict):
                    is_present = posture.get("present", False)
                    difficulty = posture.get("difficulty", "UNKNOWN")
                else:
                    is_present = bool(posture)
                    difficulty = "UNKNOWN"

                if is_present:
                    mitigated_count += 1
                    reasoning.append(f"{protection} present (bypass: {difficulty})")
                else:
                    reasoning.append(f"{protection} missing")

            # Evaluate mitigation status and effective risk
            mitigation_status, effective_risk = self._evaluate(
                base_severity=vuln.severity,
                mitigated_count=mitigated_count,
                total_deps=len(protection_deps)
            )

            # Create CorrelatedFinding object
            correlated.append(
                CorrelatedFinding(
                    owasp_id=vuln.owasp_id,
                    title=vuln.title,
                    base_severity=vuln.severity,
                    effective_risk=effective_risk,
                    mitigation_status=mitigation_status,
                    reasoning=reasoning,
                    original_finding=vuln.as_dict(),
                )
            )

        return correlated

    def _evaluate(
        self,
        base_severity: str,
        mitigated_count: int,
        total_deps: int
    ) -> tuple:
        """
        Evaluate mitigation status and effective risk
        Returns (mitigation_status, effective_risk)
        """
        if total_deps == 0:
            return "NOT_MITIGATED", base_severity

        mitigation_ratio = mitigated_count / total_deps

        if mitigation_ratio == 1.0:
            mitigation_status = "MITIGATED"
            effective_risk = self._downgrade(base_severity, steps=2)
        elif mitigation_ratio >= 0.5:
            mitigation_status = "PARTIALLY_MITIGATED"
            effective_risk = self._downgrade(base_severity, steps=1)
        else:
            mitigation_status = "NOT_MITIGATED"
            effective_risk = base_severity

        return mitigation_status, effective_risk

    def _downgrade(self, severity: str, steps: int) -> str:
        """Downgrade severity by N steps"""
        order = ["LOW", "MEDIUM", "HIGH", "CRITICAL"]
        try:
            idx = order.index(severity)
            new_idx = max(0, idx - steps)
            return order[new_idx]
        except ValueError:
            return severity

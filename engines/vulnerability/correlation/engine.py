# engines/vulnerability/correlation/engine.py

from typing import List, Dict, Any

from engines.vulnerability.models import VulnerabilityFinding
from engines.vulnerability.correlation.models import CorrelatedFinding


class CorrelationEngine:
    """
    STAGE 3: Correlation Engine (OPSI A – Rule-Based Intelligence)

    Responsibilities:
    - Correlate vulnerabilities with detected protections (ARA)
    - Downgrade effective risk (never upgrade)
    - Determine mitigation status
    - Produce transparent reasoning

    Principles:
    - Mitigation ≠ downgrade
    - Protection strength determines mitigation quality
    - Deterministic, explainable, testable
    """

    # ---------------------------------------------------------
    # Severity order (never upgrade)
    # ---------------------------------------------------------
    SEVERITY_ORDER = ["LOW", "MEDIUM", "HIGH", "CRITICAL"]

    # ---------------------------------------------------------
    # Correlation rules (OPSI A)
    # ---------------------------------------------------------
    CORRELATION_RULES = {
        # M1: Credential leakage mitigated by anti-instrumentation
        "M1": {
            "ANTI_INSTRUMENTATION": {
                "weak": {
                    "difficulty": ["LOW"],
                    "mitigation": "PARTIALLY_MITIGATED",
                    "downgrade": 0,
                    "reason": "Weak anti-instrumentation protection detected",
                },
                "medium": {
                    "difficulty": ["MEDIUM"],
                    "mitigation": "PARTIALLY_MITIGATED",
                    "downgrade": 1,
                    "reason": "Anti-instrumentation protection detected",
                },
                "strong": {
                    "difficulty": ["HIGH"],
                    "mitigation": "MITIGATED",
                    "downgrade": 2,
                    "reason": "Strong anti-instrumentation protection detected",
                },
            }
        },
        # M5: Insecure communication mitigated by SSL pinning
        "M5": {
            "SSL_PINNING": {
                "weak": {
                    "difficulty": ["LOW"],
                    "mitigation": "PARTIALLY_MITIGATED",
                    "downgrade": 0,
                    "reason": "Weak SSL pinning detected — cleartext risk partially mitigated",
                },
                "medium": {
                    "difficulty": ["MEDIUM"],
                    "mitigation": "PARTIALLY_MITIGATED",
                    "downgrade": 1,
                    "reason": "SSL pinning detected — MITM risk reduced",
                },
                "strong": {
                    "difficulty": ["HIGH"],
                    "mitigation": "MITIGATED",
                    "downgrade": 2,
                    "reason": "Strong SSL pinning — MITM risk effectively mitigated",
                },
            }
        },
        # M7: Binary protection mitigated by anti-instrumentation + anti-tampering
        "M7": {
            "ANTI_INSTRUMENTATION": {
                "weak": {
                    "difficulty": ["LOW"],
                    "mitigation": "PARTIALLY_MITIGATED",
                    "downgrade": 0,
                    "reason": "Weak anti-instrumentation — binary analysis still feasible",
                },
                "medium": {
                    "difficulty": ["MEDIUM"],
                    "mitigation": "PARTIALLY_MITIGATED",
                    "downgrade": 1,
                    "reason": "Anti-instrumentation raises reverse-engineering cost",
                },
                "strong": {
                    "difficulty": ["HIGH"],
                    "mitigation": "MITIGATED",
                    "downgrade": 2,
                    "reason": "Strong anti-instrumentation makes binary analysis impractical",
                },
            },
            "ANTI_TAMPERING": {
                "weak": {
                    "difficulty": ["LOW"],
                    "mitigation": "PARTIALLY_MITIGATED",
                    "downgrade": 0,
                    "reason": "Weak tamper detection present",
                },
                "medium": {
                    "difficulty": ["MEDIUM"],
                    "mitigation": "PARTIALLY_MITIGATED",
                    "downgrade": 1,
                    "reason": "Anti-tampering reduces binary modification risk",
                },
                "strong": {
                    "difficulty": ["HIGH"],
                    "mitigation": "MITIGATED",
                    "downgrade": 2,
                    "reason": "Strong anti-tampering prevents binary modification",
                },
            },
        },
        # M9: Insecure data storage mitigated by root detection + emulator detection
        "M9": {
            "ROOT_DETECTION": {
                "weak": {
                    "difficulty": ["LOW"],
                    "mitigation": "PARTIALLY_MITIGATED",
                    "downgrade": 0,
                    "reason": "Weak root detection — data extraction on rooted device still possible",
                },
                "medium": {
                    "difficulty": ["MEDIUM"],
                    "mitigation": "PARTIALLY_MITIGATED",
                    "downgrade": 1,
                    "reason": "Root detection reduces data extraction risk",
                },
                "strong": {
                    "difficulty": ["HIGH"],
                    "mitigation": "MITIGATED",
                    "downgrade": 2,
                    "reason": "Strong root detection — data extraction on rooted device mitigated",
                },
            },
        },
        # M10: Crypto weaknesses — anti-instrumentation makes exploitation harder
        "M10": {
            "ANTI_INSTRUMENTATION": {
                "weak": {
                    "difficulty": ["LOW"],
                    "mitigation": "PARTIALLY_MITIGATED",
                    "downgrade": 0,
                    "reason": "Anti-instrumentation slows key extraction",
                },
                "medium": {
                    "difficulty": ["MEDIUM"],
                    "mitigation": "PARTIALLY_MITIGATED",
                    "downgrade": 1,
                    "reason": "Anti-instrumentation complicates crypto key extraction",
                },
                "strong": {
                    "difficulty": ["HIGH"],
                    "mitigation": "MITIGATED",
                    "downgrade": 2,
                    "reason": "Strong anti-instrumentation — crypto key extraction impractical",
                },
            },
        },
    }

    # ---------------------------------------------------------
    # PUBLIC API
    # ---------------------------------------------------------
    def correlate(
        self,
        findings: List[VulnerabilityFinding],
        protection_profile: Dict[str, Any],
    ) -> List[CorrelatedFinding]:

        correlated: List[CorrelatedFinding] = []

        for finding in findings:
            base_severity = finding.severity.upper()

            mitigation_status = "NOT_MITIGATED"
            downgrade_steps = 0
            reasoning: List[str] = []
            mitigation_applied = False

            rules = self.CORRELATION_RULES.get(finding.owasp_id, {})

            # -------------------------------------------------
            # Apply correlation rules
            # -------------------------------------------------
            for protection_name, rule_set in rules.items():

                protection = protection_profile.get(protection_name, {})
                if not protection or not protection.get("present", False):
                    continue

                difficulty = protection.get("difficulty", "UNKNOWN")

                for rule in rule_set.values():
                    if difficulty in rule["difficulty"]:
                        mitigation_applied = True

                        mitigation_status = rule["mitigation"]
                        downgrade_steps = max(
                            downgrade_steps,
                            rule.get("downgrade", 0)
                        )

                        reasoning.append(rule["reason"])

            # -------------------------------------------------
            # Default reasoning if no mitigation applied
            # -------------------------------------------------
            if not mitigation_applied:
                reasoning.append(
                    f"No effective mitigation detected for {finding.owasp_id}"
                )

            effective_risk = self._downgrade_severity(
                base_severity,
                downgrade_steps
            )

            correlated.append(
                CorrelatedFinding(
                    owasp_id=finding.owasp_id,
                    title=finding.title,
                    base_severity=base_severity,
                    effective_risk=effective_risk,
                    mitigation_status=mitigation_status,
                    reasoning=reasoning,
                    original_finding=(
                        finding.as_dict()
                        if hasattr(finding, "as_dict")
                        else finding
                    ),
                )
            )

        return correlated

    # ---------------------------------------------------------
    # INTERNAL HELPERS
    # ---------------------------------------------------------
    def _downgrade_severity(self, severity: str, steps: int) -> str:
        """
        Downgrade severity by N steps.
        Never upgrades severity.
        """
        if severity not in self.SEVERITY_ORDER:
            return severity

        index = self.SEVERITY_ORDER.index(severity)
        new_index = max(0, index - steps)

        return self.SEVERITY_ORDER[new_index]
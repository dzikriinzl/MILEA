"""
engines/vulnerability/unified_scanner.py

Unified Single-Pass Smali Scanner — Performance-Optimised

Reads each .smali file EXACTLY ONCE and applies ALL rules simultaneously:
  • 10 Vulnerability scanners (OWASP M1–M10) → VulnerabilitySignal
  • 7 ARA categories (41+ techniques)         → ARAFinding

Key optimisations over the legacy multi-pass approach:
  1. Single I/O read per .smali file  (was 9 separate passes)
  2. ProcessPoolExecutor               (bypasses GIL for CPU-bound regex)
  3. File-level relevance pre-filter   (skip files with zero keywords)
  4. Framework path filtering          (skip androidx/, kotlin/, etc.)
  5. Context-aware ARA: const-string followed by API call → boosted confidence
  6. Noise filtering: generic strings ignored unless paired with Android API call
"""

from __future__ import annotations

import logging
import os
import re
from concurrent.futures import ProcessPoolExecutor, as_completed
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Tuple

logger = logging.getLogger(__name__)


# ═══════════════════════════════════════════════════════════════════════════
# RULE DEFINITIONS  (module-level constants — picklable for multiprocessing)
# ═══════════════════════════════════════════════════════════════════════════

# Paths that indicate framework/library code — skipped for vulnerability signals
_FRAMEWORK_PREFIXES = ("androidx/", "kotlin/", "android/support/", "android/compose/")

# Third-party library prefixes — skipped to reduce noise (vuln + ARA)
_THIRD_PARTY_PREFIXES = (
    # Android Jetpack / Kotlin stdlib
    "androidx/", "kotlin/", "kotlinx/",
    "android/support/", "android/compose/",
    # Google Play Services / Firebase / Material / all Google Android libraries
    "com/google/android/", "com/google/firebase/",
    "com/google/gson/", "com/google/protobuf/",
    # Networking / IO libraries
    "okhttp3/", "okio/", "retrofit2/",
    "com/squareup/", "com/bumptech/glide/",
    "io/reactivex/", "io/realm/",
    # Apache / JSON stdlib
    "org/apache/", "org/json/",
    # Analytics / crash reporting SDKs
    "com/facebook/", "com/crashlytics/",
    "com/adjust/sdk/", "com/appsflyer/",
    # Chromium WebView — uses Signature/PackageManager/Build for diagnostics,
    # NOT app-level ARA protection.
    "org/chromium/",
    # Flutter framework — ResourceExtractor uses getPackageInfo for file
    # timestamp management, not signature verification.
    "io/flutter/",
    # Other common runtimes / engines
    "com/unity3d/",
    "org/webrtc/",
    "tv/danmaku/",
    "com/microsoft/appcenter/",
    # SSL pinning / certificate-transparency SDKs
    "com/datatheorem/android/trustkit/",
    "com/nimbusds/jwt/",
    "net/grandcentrix/tray/",
    # Certificate Transparency library
    "com/appmattus/",
    # OkHttp certificate pinner
    "okhttp3/CertificatePinner",
    "okhttp3/internal/tls/",
)

# Root-detection libraries: their const-string arrays contain hook-framework
# package names (Xposed, Substrate, etc.) for SCANNING purposes — to detect
# those frameworks as root indicators.  Files matching these prefixes must
# NOT produce ANTI_INSTRUMENTATION findings.
_ROOT_LIBRARY_PREFIXES = (
    "com/scottyab/rootbeer",
    "com/kimchangyoun/rootbeerFresh",
    "com/kimchangyoun/rootbeer",
    "com/scottyab/rootchecker",
    "rootdetection/",
    "rootchecker/",
)

# Android API calls that validate a nearby const-string is security-relevant.
# NOTE: generic invoke-* opcodes are EXCLUDED because they match every
# single method call in smali, rendering require_api_context useless.
_ANDROID_API_CALLS: Tuple[str, ...] = (
    "cipher;->getinstance", "messagedigest;->getinstance",
    "secretkeyspec", "ivparameterspec",
    "runtime;->exec", "system;->loadlibrary",
    "packagemanager;->getpackageinfo", "packagemanager;->getinstalledpackages",
    "telephonymanager;->getdeviceid", "telephonymanager;->getimei",
    "httpurlconnection", "okhttp", "sslcontext",
    "x509trustmanager", "certificatepinner",
    "sharedpreferences", "sqlitedatabase",
    "webview;->loadurl", "webview;->addjavascriptinterface",
    "debug;->isdebuggerconnected",
)

# ---------------------------------------------------------------------------
# Vulnerability Substring Rules
# ---------------------------------------------------------------------------
# Each entry: (keywords_tuple, owasp_id, category, subtype, confidence,
#              require_api_context)
# Semantics: for each subtype group, first keyword match on a line emits ONE
# signal (matches original per-scanner break-after-first behaviour).
# If require_api_context is True, the line is only flagged when an Android
# API invocation appears within ±5 lines (noise filtering).

_VULN_GROUPS: List[Tuple[Tuple[str, ...], str, str, str, float, bool]] = [
    # ── M10  Weak Cryptography ────────────────────────────────────────
    (("messagedigest;->getinstance", "messagedigest.getinstance"),
        "M10", "INSUFFICIENT_CRYPTOGRAPHY", "weak_hash_md5", 0.75, False),
    (("sha-1", "sha1"),       "M10", "INSUFFICIENT_CRYPTOGRAPHY",       "weak_hash_sha1",         0.60, True),
    (("aes/ecb", "aes/ecb/nopadding", "des/ecb", "desede"),
        "M10", "INSUFFICIENT_CRYPTOGRAPHY", "insecure_cipher_ecb", 0.75, False),
    (("cipher;->getinstance", "cipher.getinstance"),
        "M10", "INSUFFICIENT_CRYPTOGRAPHY", "deprecated_crypto", 0.60, False),
    (("nopadding",),          "M10", "INSUFFICIENT_CRYPTOGRAPHY",       "no_padding",             0.65, True),
    (("securerandom.setseed",), "M10", "INSUFFICIENT_CRYPTOGRAPHY",     "weak_random_seed",       0.72, False),
    (("rc4", "des/cbc"),      "M10", "INSUFFICIENT_CRYPTOGRAPHY",       "weak_symmetric_cipher",  0.70, True),

    # ── M9  Insecure Data Storage ─────────────────────────────────────
    (("getsharedpreferences", "edit()"),
        "M9", "INSECURE_DATA_STORAGE", "sharedprefs_plaintext", 0.60, True),
    (("mode_world_readable", "mode_world_writeable"),
        "M9", "INSECURE_DATA_STORAGE", "world_readable_storage", 0.85, False),
    (("getexternalstoragedirectory", "getexternalfilesdir", "environment;->getexternalstorage"),
        "M9", "INSECURE_DATA_STORAGE", "external_storage_access", 0.65, False),
    (("sqliteopenhelper", "openorcreatedatabase", "sqlitedatabase;->execsql"),
        "M9", "INSECURE_DATA_STORAGE", "sqlite_plaintext", 0.60, False),
    (("fileoutputstream", "openfileoutput"),
        "M9", "INSECURE_DATA_STORAGE", "internal_file_plaintext", 0.55, True),

    # ── M4  Input Validation ──────────────────────────────────────────
    (("addjavascriptinterface", "@javascriptinterface"),
        "M4", "INSUFFICIENT_INPUT_VALIDATION", "webview_js_interface", 0.75, False),
    (("getintent", "getstringextra", "getserializableextra", "getparcelableextra", "getextras"),
        "M4", "INSUFFICIENT_INPUT_VALIDATION", "intent_extra_unvalidated", 0.55, True),
    (("getdata", "getqueryparameter"),
        "M4", "INSUFFICIENT_INPUT_VALIDATION", "uri_unvalidated", 0.55, True),
    (("webview;->loadurl", "webview;->loaddata", "webview;->loaddatawithbaseurl"),
        "M4", "INSUFFICIENT_INPUT_VALIDATION", "webview_load_untrusted", 0.60, False),
    (("evaluatejavascript",), "M4", "INSUFFICIENT_INPUT_VALIDATION",
        "webview_eval_js", 0.70, False),

    # ── M2  Supply Chain — Risky SDKs ─────────────────────────────────
    (("com/facebook/", "com.facebook.sdk", "facebooksdk"),
        "M2", "INADEQUATE_SUPPLY_CHAIN_SECURITY", "facebook_sdk", 0.65, False),
    (("com/adjust/sdk", "com.adjust.sdk"),
        "M2", "INADEQUATE_SUPPLY_CHAIN_SECURITY", "adjust_sdk", 0.60, False),
    (("io/branch/referral", "com.branch.sdk"),
        "M2", "INADEQUATE_SUPPLY_CHAIN_SECURITY", "branch_io", 0.60, False),
    (("com/bugsnag/android",),
        "M2", "INADEQUATE_SUPPLY_CHAIN_SECURITY", "bugsnag", 0.55, False),
    (("com/google/firebase/crashlytics", "com/crashlytics/android"),
        "M2", "INADEQUATE_SUPPLY_CHAIN_SECURITY", "firebase_crashlytics", 0.55, False),
    (("com/appsflyer", "appsflyer"),
        "M2", "INADEQUATE_SUPPLY_CHAIN_SECURITY", "appsflyer", 0.60, False),
    (("com/mopub",),
        "M2", "INADEQUATE_SUPPLY_CHAIN_SECURITY", "mopub", 0.70, False),

    # ── M2  Supply Chain — Weak Build Patterns ────────────────────────
    (("class.forname(", "java/lang/classloader;->loadclass",
      "dalvik.system.dexclassloader", "ldalvik/system/dexclassloader"),
        "M2", "INADEQUATE_SUPPLY_CHAIN_SECURITY", "reflection_classload", 0.68, False),
    (("ldalvik/system/dexfile", "dexclassloader", "pathclassloader"),
        "M2", "INADEQUATE_SUPPLY_CHAIN_SECURITY", "dynamic_dex_load", 0.73, False),

    # ── M3  Authentication ────────────────────────────────────────────
    (("io/jsonwebtoken", "com/auth0/jwt", "jwts;->parser"),
        "M3", "INSECURE_AUTHENTICATION", "jwt_no_verify", 0.68, False),
    (("bearer ", "authorization: ", "x-api-key"),
        "M3", "INSECURE_AUTHENTICATION", "hardcoded_token", 0.70, True),
    (("basic auth", "basicauth", "base64;->encode"),
        "M3", "INSECURE_AUTHENTICATION", "basic_auth_plaintext", 0.65, True),
    (('putstring("token', 'putstring("auth',
      'putstring("session', 'putstring("access_token'),
        "M3", "INSECURE_AUTHENTICATION", "insecure_token_storage", 0.72, False),
    (('equals("admin")', 'equals("password")', 'equals("123456")', 'equals("1234")'),
        "M3", "INSECURE_AUTHENTICATION", "weak_password_policy", 0.82, False),
    (("response_type=token", "implicit_grant", "oauth/authorize"),
        "M3", "INSECURE_AUTHENTICATION", "oauth_implicit_flow", 0.67, True),

    # ── M5  Insecure Communication ────────────────────────────────────
    (("http://",),            "M5", "INSECURE_COMMUNICATION",           "cleartext_http",         0.70, True),
    (("trustallcerts", "allowallhostnameverifier",
      "hostnameallverifier"),
        "M5", "INSECURE_COMMUNICATION", "ssl_trust_all", 0.80, False),
    (("x509trustmanager", "sslsocketfactory"),
        "M5", "INSECURE_COMMUNICATION", "ssl_custom_trust", 0.65, True),
    (("setmixedcontentmode", "mixed_content_always_allow"),
        "M5", "INSECURE_COMMUNICATION", "mixed_content_allowed", 0.72, False),

    # ── M7  Binary Protection (keyword part) ──────────────────────────
    (("android/util/log;->v(", "android/util/log;->d(", "android/util/log;->i("),
        "M7", "INSUFFICIENT_BINARY_PROTECTIONS", "log_verbose", 0.55, False),
    (("printstacktrace", "getstacktrace"),
        "M7", "INSUFFICIENT_BINARY_PROTECTIONS", "stack_trace_print", 0.65, False),
    (("getdeclaredfields", "getdeclaredmethods", "getdeclaredclasses"),
        "M7", "INSUFFICIENT_BINARY_PROTECTIONS", "reflection_enumeration", 0.60, False),
    (("flag_debuggable", "applicationinfo.flags"),
        "M7", "INSUFFICIENT_BINARY_PROTECTIONS", "debuggable_flag", 0.68, False),
    (("buildconfig.debug",),
        "M7", "INSUFFICIENT_BINARY_PROTECTIONS", "buildconfig_debug", 0.60, False),

    # ── M8  Security Misconfiguration (smali patterns) ────────────────
    (("stetho", "com/facebook/stetho"),
        "M8", "SECURITY_MISCONFIGURATION", "debug_tool_stetho", 0.72, False),
    (("strictmode", "strictmode;->setthreadpolicy"),
        "M8", "SECURITY_MISCONFIGURATION", "strictmode_enabled", 0.45, True),
]

# ---------------------------------------------------------------------------
# M1 — Hardcoded Credentials  (const-string gated, regex)
# ---------------------------------------------------------------------------

_CRED_PATTERNS: List[Tuple[str, str, str, str, float]] = [
    (r"password|passwd|pwd",         "M1", "IMPROPER_CREDENTIAL_USAGE", "hardcoded_password",    0.65),
    (r"api[_\-]?key|apikey",         "M1", "IMPROPER_CREDENTIAL_USAGE", "hardcoded_api_key",     0.65),
    (r"secret|client[_\-]?secret",   "M1", "IMPROPER_CREDENTIAL_USAGE", "hardcoded_secret",      0.65),
    (r"token|bearer",                "M1", "IMPROPER_CREDENTIAL_USAGE", "hardcoded_token",        0.65),
    (r"authorization|auth:",         "M1", "IMPROPER_CREDENTIAL_USAGE", "hardcoded_auth_header",  0.65),
    (r"private[_\-]?key|priv_key",   "M1", "IMPROPER_CREDENTIAL_USAGE", "hardcoded_private_key", 0.75),
    (r"aws[_\-]?access|aws[_\-]?secret", "M1", "IMPROPER_CREDENTIAL_USAGE", "hardcoded_aws_key", 0.80),
    (r"firebase[_\-]?key|google[_\-]?api[_\-]?key", "M1", "IMPROPER_CREDENTIAL_USAGE", "hardcoded_google_key", 0.70),
]
_CRED_COMPILED: List[Tuple[re.Pattern, str, str, str, float]] = [
    (re.compile(p, re.IGNORECASE), o, c, s, conf)
    for p, o, c, s, conf in _CRED_PATTERNS
]

# Strings to ignore in credential detection (common false positives)
_CRED_IGNORE: Tuple[str, ...] = (
    "getpassword", "setpassword", "passwordfield", "passwordedittext",
    "passwordcallback", "tokencallback", "tokenize", "tokenizer",
    "secretkeyspec", "secretkeyfactory", "passwordtransformation",
)

# ---------------------------------------------------------------------------
# M6 — Privacy  (PII source detection; network sinks checked within ±10 lines)
# ---------------------------------------------------------------------------

_PII_SOURCES: Dict[str, List[str]] = {
    "device_identifier": [
        "telephonymanager;->getdeviceid", "telephonymanager;->getimei",
        "settings$secure;->getstring", "android_id",
        "telephonymanager;->getsubscriberid",
    ],
    "location": [
        "getlastknownlocation", "requestlocationupdates",
        "fusedlocationproviderclient", "locationmanager;->getproviders",
    ],
    "advertising_id": [
        "advertisingidclient", "getadvertisingidinfo",
    ],
    "contacts": [
        "contactscontract", "content://com.android.contacts",
        "content://contacts",
    ],
    "sms": [
        "content://sms", "smsmanager;->sendtextmessage",
        "telephony.sms",
    ],
    "camera": [
        "camera;->open", "camerax", "cameramanager;->openCamera",
    ],
}
_NETWORK_SINKS: List[str] = [
    "okhttp", "httpurlconnection", "retrofit", "volley",
    "addheader", "setrequestproperty", "urlconnection",
    "httppost", "httpget", "httpclient",
]

# ---------------------------------------------------------------------------
# ARA Rules  (imported from canonical pattern library)
# ---------------------------------------------------------------------------
# Each entry: (keywords_tuple, category, technique_id, subtype, confidence)

_ARA_GROUPS: List[Tuple[Tuple[str, ...], str, str, str, float]] = []

try:
    from core.strategy.smali_ara_scanner import _PATTERNS as _ARA_SRC

    for _cat, _techniques in _ARA_SRC.items():
        for _tech_id, _info in _techniques.items():
            _ARA_GROUPS.append((
                tuple(kw.lower() for kw in _info["keywords"]),
                _cat,
                _tech_id,
                _info["subtype"],
                _info["confidence"],
            ))
except ImportError:
    logger.warning("ARA pattern import failed — ARA scanning disabled in unified scanner")


# ═══════════════════════════════════════════════════════════════════════════
# PRE-COMPILED HELPERS
# ═══════════════════════════════════════════════════════════════════════════

_CLASS_RE  = re.compile(r"\.class\s+.*\s+(L[\w/$]+;)")
_METHOD_RE = re.compile(r"\.method\s+.*\s+(\S+)\(")
_OBF_RE    = re.compile(r"^L([a-z]/){1,3}[a-z];$")

# File-level relevance filter: mega-regex of ALL keywords.
# If a file contains NONE of these, it can be skipped entirely.
def _build_filter_re() -> re.Pattern:
    kws: Set[str] = set()
    for keywords, *_ in _VULN_GROUPS:
        kws.update(keywords)
    for keywords, *_ in _ARA_GROUPS:
        kws.update(keywords)
    for pii_sources in _PII_SOURCES.values():
        kws.update(pii_sources)
    kws.update(_NETWORK_SINKS)
    kws.update(api.split(";")[0] if ";" in api else api for api in _ANDROID_API_CALLS[:10])
    # Add credential trigger
    kws.add("const-string")
    # Sort longest-first for regex preference
    sorted_kw = sorted(kws, key=len, reverse=True)
    pattern = "|".join(re.escape(k) for k in sorted_kw)
    return re.compile(pattern, re.IGNORECASE)

_FILE_FILTER_RE = _build_filter_re()


# ═══════════════════════════════════════════════════════════════════════════
# WORKER FUNCTIONS  (module-level for ProcessPoolExecutor pickling)
# ═══════════════════════════════════════════════════════════════════════════

def _scan_single_file(
    abs_path: str,
    smali_root: str,
) -> Tuple[List[dict], List[dict], Dict[str, int]]:
    """
    Scan one .smali file with ALL rules in a single read.

    Returns (vuln_signal_dicts, ara_finding_dicts, obfuscation_stats).
    """
    rel_path = os.path.relpath(abs_path, smali_root)
    is_framework = any(rel_path.startswith(p) for p in _FRAMEWORK_PREFIXES)
    is_third_party = any(rel_path.startswith(p) for p in _THIRD_PARTY_PREFIXES)
    # Root-detection libraries: allow ROOT_DETECTION signals but suppress
    # ANTI_INSTRUMENTATION (their const-strings are scan targets, not ARA).
    is_root_lib = any(rel_path.startswith(p) for p in _ROOT_LIBRARY_PREFIXES)

    # Skip third-party library files entirely — they generate noise
    if is_third_party:
        return [], [], {"total": 0, "short": 0}

    # Content-based third-party detection: obfuscated files that *reference*
    # known SDK packages (R8 renames com/google/firebase/ → o/) still flood
    # signals.  Detect by checking if file content is dominated by SDK refs.
    _SDK_CONTENT_MARKERS = (
        "com/google/firebase/", "com/google/android/gms/",
        "com/appsflyer/", "com/facebook/", "com/adjust/sdk/",
        "com/crashlytics/", "com/bumptech/glide/",
        "okhttp3/", "retrofit2/", "com/squareup/",
    )

    # ── Read file ─────────────────────────────────────────────────────
    try:
        with open(abs_path, "r", encoding="utf-8", errors="replace") as fh:
            content = fh.read()
    except Exception:
        return [], [], {"total": 0, "short": 0}

    # Content-based SDK filter: if an obfuscated file heavily references
    # third-party SDKs, treat it as third-party (skip vuln signals)
    _content_lower_quick = content[:20000].lower()
    _sdk_ref_count = sum(_content_lower_quick.count(m) for m in _SDK_CONTENT_MARKERS)
    _is_sdk_obfuscated = (
        not is_third_party  # already skipped above
        and _sdk_ref_count >= 10  # strong SDK presence
        and len(rel_path.split("/")) <= 3  # short obfuscated paths like o/X.smali
    )
    if _is_sdk_obfuscated:
        return [], [], {"total": 0, "short": 0}

    lines = content.split("\n")
    obf: Dict[str, int] = {"total": 0, "short": 0}

    # ── File-level relevance check ────────────────────────────────────
    content_lower = content.lower()
    has_relevant = bool(_FILE_FILTER_RE.search(content_lower))

    if not has_relevant:
        # Still count obfuscation stats from .class directives
        for raw_line in lines:
            stripped = raw_line.strip()
            if stripped.startswith(".class "):
                m = _CLASS_RE.search(stripped)
                if m:
                    obf["total"] += 1
                    if _OBF_RE.match(m.group(1)):
                        obf["short"] += 1
        return [], [], obf

    # ── Pre-compute lowered lines for context lookups ─────────────────
    lines_lower = [l.lower() for l in lines]

    def _has_api_context(idx: int, window: int = 5) -> bool:
        """Check if an Android API call exists within ±window lines."""
        start = max(0, idx - window)
        end = min(len(lines_lower), idx + window + 1)
        for j in range(start, end):
            if j == idx:
                continue
            for api in _ANDROID_API_CALLS:
                if api in lines_lower[j]:
                    return True
        return False

    def _has_network_sink_nearby(idx: int, window: int = 10) -> bool:
        """Check if a network sink exists within ±window lines (for M6 privacy)."""
        start = max(0, idx - window)
        end = min(len(lines_lower), idx + window + 1)
        for j in range(start, end):
            for sink in _NETWORK_SINKS:
                if sink in lines_lower[j]:
                    return True
        return False

    # ── Line-by-line scanning ─────────────────────────────────────────
    vuln_signals: List[dict] = []
    ara_findings: List[dict] = []
    class_name = ""
    method_name = ""
    ara_seen: Set[Tuple[str, str, str, str]] = set()
    vuln_subtype_count: Dict[str, int] = {}  # subtype → count for per-file cap
    _MAX_SIGNALS_PER_FILE_SUBTYPE = 3        # max signals per subtype per file
    _SDK_SUBTYPES = {"facebook_sdk", "adjust_sdk", "branch_io", "bugsnag",
                     "firebase_crashlytics", "appsflyer", "mopub"}  # 1 per file

    for i, raw_line in enumerate(lines):
        line_no = i + 1
        stripped = raw_line.strip()
        lo = stripped.lower()

        # Track class/method context
        if lo.startswith(".class "):
            m = _CLASS_RE.search(stripped)
            if m:
                class_name = m.group(1)
                obf["total"] += 1
                if _OBF_RE.match(class_name):
                    obf["short"] += 1
            continue

        if lo.startswith(".method "):
            m = _METHOD_RE.search(stripped)
            if m:
                method_name = m.group(1)
            continue

        if lo.startswith(".end method"):
            method_name = ""
            continue

        # Skip empty / directive-only lines early
        if not stripped or lo.startswith(".") or lo.startswith("#"):
            continue

        # ── Vulnerability substring rules ─────────────────────────────
        for keywords, owasp_id, category, subtype, confidence, require_ctx in _VULN_GROUPS:
            for kw in keywords:
                if kw in lo:
                    # Per-file-per-subtype cap
                    current_count = vuln_subtype_count.get(subtype, 0)
                    cap = 1 if subtype in _SDK_SUBTYPES else _MAX_SIGNALS_PER_FILE_SUBTYPE
                    if current_count >= cap:
                        break
                    # Noise filter: if require_api_context, check nearby lines
                    if require_ctx and not _has_api_context(i):
                        break
                    # Noise filter: http:// in XML namespace URIs
                    if kw == "http://" and any(
                        ns in lo for ns in (
                            "schemas.android.com", "www.w3.org",
                            "schemas.xmlsoap.org", "xml.apache.org",
                            "xmlns", "purl.org",
                        )
                    ):
                        break
                    vuln_subtype_count[subtype] = current_count + 1
                    vuln_signals.append({
                        "owasp_id":   owasp_id,
                        "category":   category,
                        "subtype":    subtype,
                        "source":     "smali",
                        "file":       abs_path,    # FULL path for localization
                        "line":       line_no,
                        "code":       stripped,
                        "evidence":   [f"{abs_path}:{line_no} — {stripped[:120]}"],
                        "confidence": confidence,
                    })
                    break  # one signal per subtype per line

        # ── M1  Credential regex (const-string gate + noise filter) ───
        if "const-string" in lo:
            # Skip if line contains known false-positive patterns
            if not any(ign in lo for ign in _CRED_IGNORE):
                for rx, owasp_id, category, subtype, confidence in _CRED_COMPILED:
                    if rx.search(lo):
                        cred_count = vuln_subtype_count.get(subtype, 0)
                        if cred_count >= _MAX_SIGNALS_PER_FILE_SUBTYPE:
                            break
                        vuln_subtype_count[subtype] = cred_count + 1
                        vuln_signals.append({
                            "owasp_id":   owasp_id,
                            "category":   category,
                            "subtype":    subtype,
                            "source":     "smali",
                            "file":       abs_path,
                            "line":       line_no,
                            "code":       stripped,
                            "evidence":   [f"{abs_path}:{line_no} — {stripped[:120]}"],
                            "confidence": confidence,
                        })
                        break  # one credential match per line

        # ── M6  Privacy (PII source with network sink within ±10 lines)
        if not is_framework:
            for pii_type, sources in _PII_SOURCES.items():
                if any(s in lo for s in sources):
                    pii_sub = f"{pii_type}_access"
                    pii_count = vuln_subtype_count.get(pii_sub, 0)
                    if pii_count >= _MAX_SIGNALS_PER_FILE_SUBTYPE:
                        break
                    # Check for network sink within ±10 lines (not same-line)
                    if _has_network_sink_nearby(i, window=10):
                        conf = 0.85
                    else:
                        conf = 0.60  # PII access still noteworthy alone
                    vuln_subtype_count[pii_sub] = pii_count + 1
                    vuln_signals.append({
                        "owasp_id":   "M6",
                        "category":   "INADEQUATE_PRIVACY_CONTROLS",
                        "subtype":    pii_sub,
                        "source":     "smali",
                        "file":       abs_path,
                        "line":       line_no,
                        "code":       stripped,
                        "evidence":   [f"{abs_path}:{line_no} — {stripped[:120]}"],
                        "confidence": conf,
                    })

        # ── ARA keyword rules (with context-aware confidence boost) ───
        for keywords, ara_cat, tech_id, subtype, confidence in _ARA_GROUPS:
            for kw in keywords:
                if kw in lo:
                    dedup_key = (class_name, method_name, ara_cat, tech_id)
                    if dedup_key not in ara_seen:
                        ara_seen.add(dedup_key)
                        # ±3 line snippet
                        s_start = max(0, i - 3)
                        s_end   = min(len(lines), i + 4)
                        snippet = [lines[j].rstrip() for j in range(s_start, s_end)]

                        # Context-aware confidence boost: if const-string is
                        # followed by an API invocation, boost confidence
                        final_conf = confidence
                        if _has_api_context(i, window=3):
                            final_conf = min(0.98, confidence + 0.08)

                        ara_findings.append({
                            "category":        ara_cat,
                            "subtype":         subtype,
                            "technique":       tech_id,
                            "file":            abs_path,   # FULL path
                            "class_name":      class_name,
                            "method_name":     method_name,
                            "line_number":     line_no,
                            "confidence":      final_conf,
                            "matched_keyword": kw,
                            "code_snippet":    snippet,
                            "source":          "smali",
                        })
                    break  # one match per technique per line

    # Suppress ANTI_INSTRUMENTATION from root-detection libraries —
    # their const-string arrays contain hook-framework package names
    # for scanning purposes, not for anti-hooking enforcement.
    if is_root_lib and ara_findings:
        ara_findings = [
            f for f in ara_findings
            if f.get("category") != "ANTI_INSTRUMENTATION"
        ]

    return vuln_signals, ara_findings, obf


def _scan_batch(
    file_entries: List[Tuple[str, str]],
) -> Tuple[List[dict], List[dict], Dict[str, int], int]:
    """
    Process-level worker: scan a batch of smali files.
    Returns (vuln_dicts, ara_dicts, obf_stats, file_count).
    """
    all_vuln: List[dict] = []
    all_ara:  List[dict] = []
    obf: Dict[str, int]  = {"total": 0, "short": 0}

    for abs_path, smali_root in file_entries:
        v, a, o = _scan_single_file(abs_path, smali_root)
        all_vuln.extend(v)
        all_ara.extend(a)
        obf["total"] += o["total"]
        obf["short"] += o["short"]

    return all_vuln, all_ara, obf, len(file_entries)


# ═══════════════════════════════════════════════════════════════════════════
# PUBLIC CLASS
# ═══════════════════════════════════════════════════════════════════════════

class UnifiedSmaliScanner:
    """
    Unified single-pass smali scanner with process-level parallelism.

    Replaces the previous 8 separate VulnerabilitySignal scanners + the
    SmaliARAScanner step, reducing total file reads from 9× to 1× and
    using ProcessPoolExecutor to bypass the GIL.
    """

    def scan_all(
        self,
        decompile_dir: Path,
        progress_cb: Any = None,
    ) -> Tuple[List, List]:
        """
        Scan every .smali file under *decompile_dir* in a single pass.

        Parameters
        ----------
        decompile_dir : Path
            Root decompilation directory (contains smali/, smali_classes2/, …).
        progress_cb : callable, optional
            ``(pct: float, msg: str) -> None`` for progress updates (0–100).

        Returns
        -------
        (List[VulnerabilitySignal], List[ARAFinding])
        """
        from engines.vulnerability.models import VulnerabilitySignal
        from core.strategy.smali_ara_scanner import ARAFinding

        def _cb(pct: float, msg: str) -> None:
            if progress_cb:
                try:
                    progress_cb(pct, msg)
                except Exception:
                    pass

        # ── Collect all .smali file paths ─────────────────────────────
        # Look in standard decompile output locations:
        #   1. smali/, smali_classes2/, etc. (apktool output)
        #   2. Nested decompile dirs (e.g. decompile/smali/)
        smali_dirs = sorted(
            d for d in decompile_dir.iterdir()
            if d.is_dir() and d.name.startswith("smali")
        )

        # If no smali dirs at top level, check for nested decompile directory
        if not smali_dirs:
            for candidate in ("decompile", "apktool_output", "output"):
                nested = decompile_dir / candidate
                if nested.is_dir():
                    nested_smali = sorted(
                        d for d in nested.iterdir()
                        if d.is_dir() and d.name.startswith("smali")
                    )
                    if nested_smali:
                        smali_dirs = nested_smali
                        logger.info(f"  [unified] found smali in nested dir: {nested}")
                        break

        file_entries: List[Tuple[str, str]] = []
        for sd in smali_dirs:
            sd_str = str(sd)
            for root, _, files in os.walk(sd):
                for fname in files:
                    if fname.endswith(".smali"):
                        file_entries.append((os.path.join(root, fname), sd_str))

        total = len(file_entries)
        if not total:
            logger.info("  [unified] no .smali files found")
            return [], []

        _cb(0, f"Collected {total} smali files for unified scan")

        # ── Partition into chunks ─────────────────────────────────────
        cpu = os.cpu_count() or 4
        num_workers = min(cpu, 8, max(1, total // 200))
        num_workers = max(1, num_workers)
        chunk_size = max(1, (total + num_workers - 1) // num_workers)
        chunks = [
            file_entries[i : i + chunk_size]
            for i in range(0, total, chunk_size)
        ]

        logger.info(
            f"  [unified] {total} files → {len(chunks)} chunk(s), "
            f"{num_workers} worker(s), ~{chunk_size} files/chunk"
        )

        # ── Launch ProcessPoolExecutor ────────────────────────────────
        all_vuln_dicts: List[dict] = []
        all_ara_dicts:  List[dict] = []
        obf_total = 0
        obf_short = 0
        completed_files = 0

        with ProcessPoolExecutor(max_workers=num_workers) as pool:
            futures = {pool.submit(_scan_batch, chunk): idx for idx, chunk in enumerate(chunks)}
            for fut in as_completed(futures):
                try:
                    vuln, ara, obf, count = fut.result()
                    all_vuln_dicts.extend(vuln)
                    all_ara_dicts.extend(ara)
                    obf_total += obf["total"]
                    obf_short += obf["short"]
                    completed_files += count
                    _cb(
                        completed_files / total * 100,
                        f"Scanned {completed_files}/{total} smali files",
                    )
                except Exception as exc:
                    logger.warning(f"  [unified] worker error: {exc}")

        # ── Convert dicts → dataclass instances ───────────────────────
        signals: List[VulnerabilitySignal] = [
            VulnerabilitySignal(**d) for d in all_vuln_dicts
        ]
        findings: List[ARAFinding] = [
            ARAFinding(**d) for d in all_ara_dicts
        ]

        # ── M7 obfuscation check (file-level, runs once) ─────────────
        if obf_total > 20:
            not_obfuscated = obf_total - obf_short
            if not_obfuscated > obf_total * 0.2:
                signals.append(VulnerabilitySignal(
                    owasp_id="M7",
                    category="INSUFFICIENT_BINARY_PROTECTIONS",
                    subtype="no_obfuscation",
                    source="smali",
                    file="(global)",
                    line=None,
                    code=None,
                    evidence=[
                        f"Only {obf_short}/{obf_total} class files appear obfuscated. "
                        f"ProGuard/R8 may not be enabled for this build."
                    ],
                    confidence=0.72,
                ))

        logger.info(
            f"  [unified] done — {len(signals)} vuln signals, "
            f"{len(findings)} ARA findings, "
            f"obf={obf_short}/{obf_total}"
        )

        return signals, findings
